lib\+NMEA is a library created for the purpose of easy implementation of GPS features in your embedded system based on STM32 MCU\textquotesingle{}s. It is compatible with GPS modules which are using NMEA protocol and UART communication. The library uses HAL functions so HAL must be included in your project. I used STM32\+Cube\+IDE to create this library and Cube\+MX to initialize MCU.\hypertarget{md_README_autotoc_md1}{}\doxysection{Why you should consider this library}\label{md_README_autotoc_md1}
\hypertarget{md_README_autotoc_md2}{}\doxysubsection{Comparison to other similar libraries}\label{md_README_autotoc_md2}
I have seen a lot of similar libraries on the Git\+Hub. Unfortunately all of them have some important issues like\+:


\begin{DoxyItemize}
\item Properly parsing only full message (with no empty fields)
\item UART interrupt for every single incoming character
\item Lack of checksum control
\item Lack of error/status codes to interact with oder parts of the software
\end{DoxyItemize}\hypertarget{md_README_autotoc_md3}{}\doxysubsection{Key features}\label{md_README_autotoc_md3}
\hypertarget{md_README_autotoc_md4}{}\doxysubsubsection{Parsing messages with empty fields}\label{md_README_autotoc_md4}
I have implemented a custom parser that can return a pointer to NULL value. Thanks to it every message is parsed properly even if it contains blank fields. \hypertarget{md_README_autotoc_md5}{}\doxysubsubsection{UART with DMA}\label{md_README_autotoc_md5}
Thanks for custom function detecting IDLE UART flag (not included in HAL) it was possible to implement data receiving with DMA. It generates only one IT for single transmission. \hypertarget{md_README_autotoc_md6}{}\doxysubsubsection{Checksum control}\label{md_README_autotoc_md6}
Special function is calculating checksum for every incoming NMEA message and compares it with the checksum given. \hypertarget{md_README_autotoc_md7}{}\doxysubsubsection{Status codes returning by the functions}\label{md_README_autotoc_md7}
Library functions are returning special status codes\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \textcolor{keyword}{enum} \{}
\DoxyCodeLine{    \mbox{\hyperlink{libNMEA_8h_a6455e1040e29859f724cdef604f09a6ca271fd6e6d43f2e4ae68b0efdb6851e38}{NMEA\_OK}}=0,      }
\DoxyCodeLine{    \mbox{\hyperlink{libNMEA_8h_a6455e1040e29859f724cdef604f09a6ca6c7cb621af84febab9c28895b881c0a0}{NMEA\_BUFFER\_OVERFLOWED}}, }
\DoxyCodeLine{    \mbox{\hyperlink{libNMEA_8h_a6455e1040e29859f724cdef604f09a6cac2605308bed3c5366d380a0387536331}{NMEA\_CHECKSUM\_ERROR}},    }
\DoxyCodeLine{    \mbox{\hyperlink{libNMEA_8h_a6455e1040e29859f724cdef604f09a6caa198a2bb859684b08d586b87e9f38d98}{NMEA\_WRONG\_DATA}},    }
\DoxyCodeLine{    \mbox{\hyperlink{libNMEA_8h_a6455e1040e29859f724cdef604f09a6caf52d9819bb63d8f9a3f5a1f1c5d9e9ac}{NMEA\_WRONG\_CB\_ID}},   }
\DoxyCodeLine{    \mbox{\hyperlink{libNMEA_8h_a6455e1040e29859f724cdef604f09a6ca58c7c4496b8a08ac8640b0f9d4957590}{NMEA\_ERROR}}      }
\DoxyCodeLine{\}\mbox{\hyperlink{libNMEA_8h_a6455e1040e29859f724cdef604f09a6c}{NMEA\_status}};}

\end{DoxyCode}
\hypertarget{md_README_autotoc_md8}{}\doxysubsubsection{Callback functions for events}\label{md_README_autotoc_md8}
I have implemented a system of callback functions for some events. Using it you can realize measurements, warnings etc. At the moment you can register callbacks for 3 events\+:
\begin{DoxyItemize}
\item speed change
\item upward speed limit violation
\item downward speed limit violation
\end{DoxyItemize}

For more information see code documentation.\hypertarget{md_README_autotoc_md9}{}\doxysubsubsection{All data close at hand}\label{md_README_autotoc_md9}
nmea\+\_\+data is instance of \mbox{\hyperlink{structNMEA__data}{NMEA\+\_\+data}} structer. You have acces to it in your code to acces important and actual data whenever you need. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \textcolor{keyword}{struct}\{}
\DoxyCodeLine{    \textcolor{keywordtype}{float}       UTC\_time; }
\DoxyCodeLine{    \textcolor{keywordtype}{int}         UT\_date;}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{keywordtype}{float}       latitude;}
\DoxyCodeLine{    \textcolor{keywordtype}{char}        latitude\_direction;}
\DoxyCodeLine{    \textcolor{keywordtype}{float}       longitude;}
\DoxyCodeLine{    \textcolor{keywordtype}{char}        longitude\_direction;}
\DoxyCodeLine{    \textcolor{keywordtype}{float}       altitude;}
\DoxyCodeLine{    \textcolor{keywordtype}{float}       geoidal\_separation;}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{keywordtype}{float}       speed\_kmph;}
\DoxyCodeLine{    \textcolor{keywordtype}{float}       speed\_knots;}
\DoxyCodeLine{    }
\DoxyCodeLine{    uint8\_t     sat\_in\_view;}
\DoxyCodeLine{    uint8\_t     sat\_in\_use;}
\DoxyCodeLine{    }
\DoxyCodeLine{    uint8\_t     fix;}
\DoxyCodeLine{    uint8\_t     fix\_mode;}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{keywordtype}{float}       PDOP;}
\DoxyCodeLine{    \textcolor{keywordtype}{float}       HDOP;}
\DoxyCodeLine{    \textcolor{keywordtype}{float}       VDOP;}
\DoxyCodeLine{}
\DoxyCodeLine{\}\mbox{\hyperlink{structNMEA__data}{NMEA\_data}};}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{structNMEA__data}{NMEA\_data}} \mbox{\hyperlink{libNMEA_8h_a385a22547d1d9ec0c2cb0066b185c4b4}{nmea\_data}};}

\end{DoxyCode}
 For more information see code documentation.\hypertarget{md_README_autotoc_md10}{}\doxysection{Integrating library with your code}\label{md_README_autotoc_md10}
In Cube\+MX follow these steps\+:
\begin{DoxyItemize}
\item Select UART/\+USART port for your GPS module
\item Select async mode
\item Turn on global interrupt
\item Select DMA channel for UART/\+USART RX
\item Generate Code
\end{DoxyItemize}

In the \char`\"{}lib\+NMEA.\+h\char`\"{} file change


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}stm32l4xx\_hal.h"{}}}

\end{DoxyCode}


to file specific to your hardware.

In the \char`\"{}main.\+h\char`\"{} add


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{libNMEA_8h}{libNMEA.h}}"{}}}

\end{DoxyCode}


in user includes section

In file \char`\"{}stm32\+XXxx\+\_\+it.\+c\char`\"{} specific for your hardware place


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} UART4\_IRQHandler(\textcolor{keywordtype}{void})}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{comment}{//USER CODE BEGIN UART4\_IRQn 0}}
\DoxyCodeLine{    }
\DoxyCodeLine{    \mbox{\hyperlink{libNMEA_8c_a12e9ebb3cb9f8b25b7e10666fb3c49d4}{user\_UART\_IDLE\_IT\_handler}}();}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{//USER CODE END UART4\_IRQn 0}}
\DoxyCodeLine{}
\DoxyCodeLine{    ...}

\end{DoxyCode}
 In the main function after peripheria initialization place


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{libNMEA_8c_a4512ff2b1b47cf5b15b0c80610a59096}{NMEA\_init}}(\&huart4, \&hdma\_uart4\_rx);   \textcolor{comment}{/*library initialization. Pass the UART and DMA handler structures*/}}

\end{DoxyCode}


with handlers to defined structures and


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{/* Infinite loop */}}
\DoxyCodeLine{\textcolor{comment}{/* USER CODE BEGIN WHILE */}}
\DoxyCodeLine{\textcolor{keywordflow}{while} (1)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \mbox{\hyperlink{libNMEA_8c_a3de145f81ae94d22ed27c673b9e8b08d}{NMEA\_process\_task}}();  \textcolor{comment}{/*library process. PLACE IT IN THE MAIN LOOP! Note that you should handle the status codes.*/}}

\end{DoxyCode}


inside the infinitive loop.

Thats it! Now you are ready to use GPS features in your embedded system!

Check out the example \char`\"{}main.\+c\char`\"{} to understand how to play with callback functions.

I highly recommend to read the documentation when you clone the repository (e.\+g. \char`\"{}html/index.\+html\char`\"{}) and read the source before integration with the system process. 